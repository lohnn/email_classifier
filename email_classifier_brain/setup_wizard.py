import os
import subprocess
import shutil
import getpass
import re
import sys
from pathlib import Path

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def print_header(text):
    print("\n" + "=" * 60)
    print(f"  {text}")
    print("=" * 60 + "\n")

def check_dependency(name, install_msg):
    if shutil.which(name):
        print(f"  [✓] {name} is installed.")
        return True
    else:
        print(f"  [ ] {name} is NOT installed.")
        print(f"      {install_msg}")
        return False

def get_input(prompt, default=None, current=None, is_password=False):
    if current:
        display_val = "********" if is_password else current
        display_prompt = f"{prompt} [{display_val}]: "
    elif default:
        display_prompt = f"{prompt} ({default}): "
    else:
        display_prompt = f"{prompt}: "

    if is_password:
        val = getpass.getpass(display_prompt).strip()
    else:
        val = input(display_prompt).strip()

    if not val:
        return current if current else default
    return val

def update_env_file(filepath, new_values):
    """
    Updates the .env file while preserving comments and order.
    """
    if not os.path.exists(filepath):
        with open(filepath, 'w') as f:
            f.write("# Generated by setup_wizard.py\n")
            for k, v in new_values.items():
                if v is not None:
                    f.write(f"{k}={v}\n")
        return

    with open(filepath, 'r') as f:
        lines = f.readlines()

    updated_keys = set()
    new_lines = []

    for line in lines:
        # Match KEY=VALUE with optional whitespace and inline comments
        # Group 1: Leading whitespace
        # Group 2: Key
        # Group 3: Optional whitespace around '='
        # Group 4: Value (everything up to first whitespace followed by #)
        # Group 5: Rest of the line (including comments)
        match = re.match(r'^(\s*)([A-Za-z_][A-Za-z0-9_]*)(\s*=\s*)([^#\s]*)(\s*#.*)?$', line.rstrip())
        if match:
            indent, key, equals, old_val, comment = match.groups()
            if key in new_values:
                val = new_values[key]
                # If the value contains spaces, we might want to quote it,
                # but standard .env usually doesn't strictly require it unless it's complex.
                # For simplicity, we just write the value.
                comment_str = comment if comment else ""
                new_lines.append(f"{indent}{key}{equals}{val}{comment_str}\n")
                updated_keys.add(key)
                continue
        new_lines.append(line)

    # Add any new keys that weren't in the original file
    for key, value in new_values.items():
        if key not in updated_keys and value is not None:
            if new_lines and not new_lines[-1].endswith('\n'):
                new_lines.append('\n')
            new_lines.append(f"{key}={value}\n")

    with open(filepath, 'w') as f:
        f.writelines(new_lines)

def load_env(filepath):
    env = {}
    if os.path.exists(filepath):
        with open(filepath, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                if '=' in line:
                    k, v = line.split('=', 1)
                    k = k.strip()
                    v = v.strip()
                    # Remove quotes if present
                    if (v.startswith('"') and v.endswith('"')) or (v.startswith("'") and v.endswith("'")):
                        v = v[1:-1]
                    env[k] = v
    return env

def run_command(cmd, cwd=None):
    """Helper to run a command and return success."""
    try:
        subprocess.run(cmd, cwd=cwd, check=True, capture_output=True, text=True)
        return True
    except subprocess.CalledProcessError as e:
        print(f"Error running command {' '.join(cmd)}: {e.stderr}")
        return False
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return False

def main():
    clear_screen()
    print_header("Email Classifier — Setup Wizard")

    # 1. Dependency Checks
    print("Checking system dependencies...")
    has_git = check_dependency("git", "Required for cloning training data.")
    has_git_lfs = check_dependency("git-lfs", "Required for model versioning. Install with 'sudo apt install git-lfs' or 'brew install git-lfs'.")
    has_rclone = check_dependency("rclone", "Required for model syncing. Install with 'sudo apt install rclone' or 'brew install rclone'.")

    if has_git_lfs:
        print("  → Initializing Git LFS...")
        run_command(["git", "lfs", "install"])

    if not has_git or not has_git_lfs or not has_rclone:
        print("\n⚠️  Some system dependencies are missing. You may need to install them before proceeding.")
        input("Press Enter to continue anyway...")

    # 2. Setup Mode
    print_header("Setup Mode")
    print("1. Training Machine (High CPU/GPU, used for training models)")
    print("2. Server Machine (Raspberry Pi or similar, used for inference)")
    print("3. Both (Development machine)")

    mode = ""
    while mode not in ["1", "2", "3"]:
        mode = input("\nSelect setup mode [1-3]: ").strip()

    is_training = mode in ["1", "3"]
    is_server = mode in ["2", "3"]

    # 3. .env configuration
    print_header("Environment Configuration")
    env_path = ".env"
    current_env = load_env(env_path)
    new_env_values = {}

    # Always needed
    new_env_values["MY_EMAIL"] = get_input("Your email address(es) (comma-separated)",
                                           default="me@company.com",
                                           current=current_env.get("MY_EMAIL"))

    # Server/Inference settings
    if is_server:
        print("\n--- IMAP Settings (Server Mode) ---")
        new_env_values["IMAP_SERVER"] = get_input("IMAP Server",
                                                 default="imap.gmail.com",
                                                 current=current_env.get("IMAP_SERVER"))

        default_user = new_env_values["MY_EMAIL"].split(',')[0]
        new_env_values["IMAP_USER"] = get_input("IMAP Username",
                                               default=default_user,
                                               current=current_env.get("IMAP_USER"))

        new_env_values["IMAP_PASSWORD"] = get_input("IMAP Password / App Password",
                                                   current=current_env.get("IMAP_PASSWORD"),
                                                   is_password=True)

        new_env_values["IMAP_BATCH_SIZE"] = get_input("IMAP Batch Size",
                                                     default="50",
                                                     current=current_env.get("IMAP_BATCH_SIZE"))

    # Model & Data paths
    print("\n--- Paths & Sync ---")
    if is_training:
        default_data_dir = "../email_classifier_data"
        new_env_values["TRAINING_DATA_DIR"] = get_input("Training Data Directory",
                                                       default=default_data_dir,
                                                       current=current_env.get("TRAINING_DATA_DIR"))

        # If they use the default local TrainingData, we don't want to mess with sibling dirs
        if new_env_values["TRAINING_DATA_DIR"] == "TrainingData":
             default_model_dir = "model"
        else:
             default_model_dir = str(Path(new_env_values["TRAINING_DATA_DIR"]) / "model")

        new_env_values["MODEL_DIR"] = get_input("Model Directory",
                                               default=default_model_dir,
                                               current=current_env.get("MODEL_DIR"))
    else:
        new_env_values["MODEL_DIR"] = get_input("Model Directory",
                                               default="model",
                                               current=current_env.get("MODEL_DIR"))

    new_env_values["GDRIVE_REMOTE"] = get_input("Rclone Google Drive Remote Name",
                                               default="gdrive",
                                               current=current_env.get("GDRIVE_REMOTE"))

    new_env_values["GDRIVE_MODEL_PATH"] = get_input("Google Drive Model Path",
                                                   default="email-classifier-model",
                                                   current=current_env.get("GDRIVE_MODEL_PATH"))

    update_env_file(env_path, new_env_values)
    print(f"\n✓ Configuration saved to {env_path}")

    # 4. Training Data Repo Setup
    if is_training and new_env_values["TRAINING_DATA_DIR"] != "TrainingData":
        print_header("Training Data Repository")
        data_dir = Path(new_env_values["TRAINING_DATA_DIR"])
        if data_dir.exists():
            print(f"Directory {data_dir} already exists.")
            if (data_dir / ".git").exists():
                 choice = input("Training data repo already exists. Update it now? (Y/n): ").lower()
                 if choice != 'n':
                     print("Updating existing repository...")
                     run_command(["git", "pull"], cwd=str(data_dir))
            else:
                 print(f"Warning: {data_dir} exists but is not a git repo.")
        else:
            choice = input(f"Training data repo not found at {data_dir}. Clone it now? (Y/n): ").lower()
            if choice != 'n':
                repo_url = input("Enter Training Data Git Repo URL: ").strip()
                if repo_url:
                    run_command(["git", "clone", repo_url, str(data_dir)])

    # 5. Rclone Check
    if has_rclone:
        print_header("Rclone Configuration")
        remote_name = new_env_values["GDRIVE_REMOTE"]
        try:
            result = subprocess.run(["rclone", "listremotes"], capture_output=True, text=True)
            if f"{remote_name}:" in result.stdout:
                print(f"✓ Rclone remote '{remote_name}' is configured.")
            else:
                print(f"⚠️  Rclone remote '{remote_name}' NOT found.")
                print(f"Please run 'rclone config' to set up a Google Drive remote named '{remote_name}'.")
        except Exception:
            print("Could not verify rclone remotes.")

    # 6. Final Instructions
    print_header("Setup Complete!")
    if is_training:
        print("To start training:")
        print("  ./retrain.sh")
        print("  (or use 'python3 train.py' for local training only)")
        print("")
    if is_server:
        print("To start the server:")
        print("  ./run_service.sh")
        print("")

    print("Happy classifying!")

if __name__ == "__main__":
    main()
